// ignore_for_file: file_names

void main() {

///ООП - стиль программирования, основанный на классах и объектах.
///Другими словами методология или парадигма разработки, где данные в программе 
///формируются в объекты с учетом определенного уровня абстракций. Между объектами
///иерархические связи, а каждый объект - законченная программная единица, обладающая
///опред свойствами и методами взаимодействия с ней. 

///Что такое объект?
///В ООП чертеж, схема, описание или шаблон из реальной жизни называется классом, 
///из которого при выполнении программы создается объект
///Класс-описание еще не созданного объекта, как бы общий шаблон, состоящий из полей,
///методов и конструктора, а объект - экземпляр класса, созданный на основе этого
///описания.
///Конструктор - спец метод, блок инструкций, который вызывается при создании объекта.
///Он также может принимать некоторые аргументы. Обычно в констр свойствам объекта
///присваиваются некоторые знач.
///Объект - некоторая структура данных, у которой доступен набор свойств и методов.
///Объект может наследовать свойства и методы у какой-то другой родительской сущности
///и может сам являться родитеским для некоторого производного объекта

///Интерфейс - набор свойств и методов объекта. Если в объекте доступны свойства 
///и методы того или иного интерфейса, говорят что объект реализует данный интерфейс.
///Интерфейс как оглавление в учебнике, он говорит что надо сделать, но не говорит
///как это надо сделать.
///Интерфейс не имеют конкретной реализации, поэтому каждый объект имеет возможность
///реализовать интерфейс по своему
///!пример для собеса: вот есть интерфейс написание кода, и я и тот кто будет собеседовать
///реализуем один и тот же интерфейс - написание кода. Но выглядеть он будет по разному,
///у меня это наполовину говнокод местами, со спорными именами переменных и не совсем чистым кодом
///а у собеседующего это уже отличный, прилизанный код
///Абстрактные классы похожи на интерфейсы, в них также можно объявлять абстрактные
///методы(похожи на методы интерфейсов потому что не имеют реализации). Но при этом
///в них можно создавать и обычные классы с какой-то реализацией и логикой и класс
///который будет наследоваться от абстр унаследует все обычные методы.

///Абстракция ООП - способ представления элементов задачи из реального мира в 
///виде объектов в программе. Абстракция всегда связана с обобщением некоторой инфы 
///о свойствах предметов или объектов, поэтому главно - отделить значимую инфу
///от незначимой в контексте решаемой задачи. При этом уровней абстракции может быть
///несколько.


///Инкапсуляция
///Если с помощью Абстракции мы выделяем общее для всех объектов. Однако каждая
///единица чего либо имеет и индивидуальность. Как же в программе эту индивид 
///обозначить. Для этого используют принцип инкапсуляции - при котором атрибуты
///и поведение объекта объединяются в одном классе, внутренняя реализация скрывается
///от пользователя, а для работы с объектом предоставляется открытый интерфейс.
///Задача программиста - какие атрибуты и методы будут доступны для открытого
///доступа а какие являются внутренней реализацией объекта и должны быть недоступны
///для изменений.
///Понятие инкапсуляции очень тесно перекликается с таким понятием как сокрытие.
///Сам класс - это капсула, в ней свойства и методы для работы с этими свойствами.
///То есть она позволяет их объединить.

///Инкапсуляция и управление доступом
///Характеристика чего-либо - это его состояние. В Java состояние будущих объектов
///описывается в классе с помощью полей, а их поведение - с помощью методов
///Возможность же изменения состояния и поведения осуществляется с помощью
///модификаторов доступа к полям и методам - private, public. Private - свойства
///и методы можно использовать только внутри класса, извне вызвать невозможно, у 
///public соответственно наоборот - вызывать извне можно. 
///Предоставление открытых методов для работы с объектом также является частью 
///механизма инкапсуляции, так как если полностью закрыть доступ к объекту -он
///станет бесполезным
///Чаще всего все свойства делают приватными, а для того чтобы получать доступ к
///этим свойствам - создаются геттеры и сеттеры. Если явно не указывают модификатор
///доступа -по умолчанию он становится public. Обычно напрямую доступны только те
/// свойства объекта, которые невозможно изменить - константы. Значение всех 
/// прочих свойств запрашивается не напрямую а через Геттеры- методы возвращающие 
/// текущее значение того или иного свойства. Изменяются же значения
///через Сеттеры-методы получающие во входном параметре новое знач свойств. Сеттер
///может выполнить опред проверки нового параметра и в случае несоответствия - 
///не устанавливать новое значение



///Наследование
///В программировании наследование - использование уже существующих классов для 
///описания новых.
///Также наследование называют расширением, поэтому при наследовании используют
///ключевое слово extends.
///Использования его позволяет значительно уменьшить объем кода и облегчить работу
///программиста.

///Полиморфизм
///Принцип, когда программа может использовать объекты с одинаковым интерфейсом без
///инфо о внутреннем устройстве объекта.
///Принцип, позволяющий одному и тому же фрагменту кода работать с разными типами
///данных.
///Основное преимущество полиморфизма - выбор реализации в процессе выполнения программы,
///это называется динамическим

///Пример с авто из видео

///Абстрактный класс:базовый автомобиль. Абстрактный значит нельзя создавать 
///экземпляры данного класса, он только задает первоначальный макет.
///цвет и владелец - два свойства нашего класса, плюс добавляем стиль вождения. У
///этого же класса будет абстрактный геттер - запас хода

///Унаследуем от базового авто - сущность автомобиль с двс. Свойства: кол-во 
///горючего и объем бензобака(оба свойства сделаем приватными, а доступ к текущему
///уровню топлива через геттер). Также у данной сущности 3 метода:заправить, нажать
///на газ, нажать на тормоз.
///!Обратим внимание что наша архитектура соответствует принципу инкапсуляции. В реальном
///мире мы не измеряем уровень топлива напрямую, для этого есть индикатор на 
///приборной панели - геттер.

///Унаследуем от автомобиля с двс - авто марки ultra. В нем зададим объем бензобака
///и реализацию стиля вождения. Цвет зададим множеством[красный, синий, зеленый].
///Для обработки данных о стиле вождения - создадим интерфейс с тремя методами:
///была нажата педаль газа, нажат тормоз, получить запас хода. Реализовывать этот
///интерфейс будет спец класс - стиль вождения ultra   




}
