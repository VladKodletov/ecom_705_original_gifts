// ignore_for_file: prefer_const_declarations, avoid_print, unused_local_variable, file_names, unused_element

void main() {
  ///слово void(пустота) вначале функции - указывает что она не возвращает значения
  ///а просто выполняет действия.
  ///main -имя функции, пустые скобки - значит ф-ия не принимает параметров.
  ///но можем использовать форму main которая принимает параметры и передать
  ///функции данные извне при запуске программы
  ///После пустых скобок идет блок функции в виде фиг скобок {внутри которых
  ///помещаем набор выполн инструкций(действий, которые выполняет прогр)}

  ///Инструкции(statement) - основной строй блок в программе на Dart. Каждая инстр
  ///выполняет некот действие - вызов методов, объявление перем. и присв. им знач.
  ///После завершения инструкции в Dart ставится ; Этот знак указывает на конец инстр.
  print('Hello Dart');

  ///Кроме отдельных инструкций распространенной конструкцией является блок кода.
  ///Блок кода - набор инструкций, закл в фиг скобки
  ///функция main по сути тоже блок кода, но внутри может содержать и другие БК

  ///Переменные и константы
  ///Имя переменной - может содержать алфавит цифровые символы и символ подчеркивания, но
  ///!не должно совпадать с одним из ключ слов языка
  const a = 5;
  const int b = 6;
  final int c = 8;
  final d = 9;
  print(
      "a:$a b:$b c:$c d:$d"); //применяется интерполяция, которая после симфола
  //$ позволяет указать имя переменной значение которой будет выводиться.

  ///Примитивные типы данных
  ///Логический тип bool
  ///Числовой - int double
  ///Строковый - String Runes
  ///Symbol

  ///int-занимает не более 64 бит в завис от платформы(Dart VM -2 в 63 степени до
  ///2 в 63 ст -1). Dart компилирующийся в JS использует знач -2 в 53 степ до
  ///2 в 53 ст -1

  ///double - числа с плав точкой, занимают 64 бита. Можно присвоить целочисл.
  ///значение, тогда преобразуется в дробное с 0 после точки.

  ///String - UTF-16. Если нужно определить многострочную строку закл в '''
  ///здесь несколько строк''';
  ///!Интерполяция - ввод в строку значения других переменных.
  ///Для ввода - в строку перед переменной ставится знак доллара $($name, $age), в
  ///итоге вместо $name вставится значение переменной name.
  ///
  ///Runes - в UTF-32 или Unicode. Используется спец синтаксис. Для определения
  ///значения типа Runes используется конструктор данного типа=>
  Runes input = Runes('\u041F\u0440\u0438\u0432\u0435\u0442');

  ///Для получение текста - применяется метод String.fromCharCodes
  print(String.fromCharCodes(input));

  ///Symbol - наименее используемый тип. Представляет симфолы. Применяется для
  ///ссылки на элементы API, например библиотеки и классы. Для определения объекта
  ///этого типа применяется симфол # перед значением

  ///!!! null, nullable-типы и null-безопасность

  ///null - спец константа, которая говорит, что у переменной или константы по
  ///сути отсутствует значение. Однако при использовании этой константы надо учитывать
  ///что с версии 2.12 в Dart по умолчанию применяется null-безопасность(другими
  ///словами null-safety).
  /*String name5;
    print(name5); // выдает ошибку, так как мы используем переменную до присвоения ей значения
    name5 = "Tom";
    print(name5);*/
  ///!По умолчанию - все типы данных расцениваются как типы, которые не допускают
  ///значение null, поэтому мы обязательно должны присваивать их переменным и константам
  ///значение перед использованием.

  ///Оператор ? и nullable-типы
  ///Но в некот случаях нужно чтобы перем или конст не имела никакого значения(
  ///то есть могла принимать значение null).
  ///Для этого можем использовать nullable-типы
  ///По сути это это двойники обычных типов, но которые могут принимать значение
  ///null. Чтобы отметить тип как nullable(допускающий значение null) после
  ///названия типа ставится оператор ?
  String? name;
  print(name);
  name = "Tom";
  print(name);

  ///Можно даже явным образом присваивать таким переменным значение null
  String? name3 = "Tom";
  print(name3);
  name3 = null;
  print(name3);
  //Оператор ??
  /// Этот оп-р при присвоении переменной выполнит проверку на null.
  ///value1 ?? value2
  ///Здесь если value1 не равно null, то оператор вернет именно это значение value1.
  ///Если же это значение равно null, то оператор ?? возвращает value2.
 /* int? num1 = 23;
  int num2 = num1 ?? 0;
  print(num2); // 23

  num1 = null;
  num2 = num1 ?? 0;
  print(num2); // 0 */
  ///При первом присвоении переменная num2 получит значение переменной num1
  ///(число 23), так как num1 не равна null. При втором присвоении num2
  ///получит значение 0, так как num1 равна null.

  ///Оператор !
  ///В некоторых ситуациях переменная можеть быть определена как nullable-типа,
  ///но могут быть исключены случаи что данная переменная будет хранить null.
  ///Если мы точно в этом уверены, то мы можем принимать оператор !.
  /* int? a = 23;
    int b = a!; // мы уверены, что a не равна null
    print(b);       // 23*/
  ///Но лучше не злоупотреблять этим

  ///Арифметические операции
  ///Делятся на бинарные(производятся над двумя операндами) и унарные(выполняются
  ///над одним операндом)
  ///Бинарные:
  ///+ - сложение; - вычитание; * - умножение; / - деление(стоит учитывать, что
  ///результат операции всегда тип double);
  ///~/ операция целочисленного деления двух чисел(результат - всегда int)
  int ab = 33;
  int bc = 5;
  int cd = ab ~/ bc; //6
  int de = 22 ~/ 4; //5
  ///% получение остатка от деления двух чисел
  int af = 33;
  int bf = 5;
  int cf = af % bf; //3
  int df = 22 % 4; //5
  ///Далее унарные(над одним числом) - инкремент ++ и декремент --
  ///++ префиксный инкремент - z = ++y(вначале знач. переменной y увеличивается на
  ///1, а затем ее значение присваивается переменной z)
  int ag = 8;
  int bg = ++ag;
  print(ag); //9
  print(bg); //9
  ///++ постфиксный инкремент - z = y++(вначале знач переменной y
  ///присваивается перем z, а потом значение у увеличивается на 1)
  int ak = 8;
  int bk = ak++;

  print(ak); //9
  print(bk); //8
  ///--(префиксный и постфиксный декремент) - аналогично инкременту
  /// Приоритет арифм операций
  /// Операции в порядке уменьшения приоритета:
  /// ++(постфиксный инкремент), --(постфик декр)
  /// ++ (преф инкрем), -- (преф декрем)
  /// * (умн), / (деление), % (остаток от деления)
  /// + (сложение), - (вычитание)
  int al = 8;
  int bl = 7;
  int cl =
      al + 5 * ++bl; //48 => вначале ++bl(увеличит знач перем bl и возвратит
  /// его в кач результата), затем умн 5 * ++bl, и только потом сложение с al
  /// Для переопределения порядка вычислений добавляем скобки
  // int cl = (al + 5) * ++b => 104
  int aa = 4;
  int bb = 5;
  int cc = aa + 5 * bb++;
  print(bb); //6
  print(
      cc); //29   Сначала выполняется b++, которое увеличивает знач bb на 1(то есть
  ///теперь оно 6), но возвр знач перем до увеличения (то есть 5). Далее 5*5
  /// и 4 + 5*5 = 29

  int az = 4;
  int bz = 4;

  int cz = ++az * 5 + az;
  int dz = bz + 5 * ++bz;

  print('cz + $cz'); //30
  print(
      'dz + $dz'); //29 //не оч понял почему? потому что bz стоит вначале строки?

  ///Побитовые операции и операции сдвига
  ///Выполняются над отдельными разрядами или битами числа. Каждое число имеет
  ///двоичное представление 4 это 100(три цифры-три разряда), 5 это 101(три разряда)
  ///Логические операции
  /// & -(логическое умножение), производится поразрядно(первое с первым и тд)
  /// | -(лог сложение), тоже поразрядно, но теперь возвращается единица если хотя бы
  /// у одного числа в разряде есть 1(операция "логическое ИЛИ")
  /// ^ -(лог исключающее ИЛИ), также XOR. Тоже поразрядно. Если знач разные, то
  /// возвр единица, иначе 0
  /// ~ - (логическое отрицание) - поразрядная операция, которая инвертирует
  /// все разряды числа: если знач разряда 1, то оно становится равным нулю и наоборот
  /// Операции сдвига <<(влево) и >>(вправо).
  /// a<<b(сдвигает число а влево на b разрядов) и наоборот.
  /// Подробнее по ссылке снизу(не сказать что сразу все понял)
  ///https://metanit.com/dart/tutorial/2.5.php

  ///Условные выражения.
  ///Представляют некоторое условие и возвр значение типа bool(либо true либо
  ///false). К ним относятся: операции сравнения и логические операции.
  ///Операции сравнения
  ///Сравниваются два операнда и возвращ знач типа bool.
  ///== (сравнивает на Равенство и возвр true если равны и наоборот)
  ///!= (на неравенство, true если Не равны и наоборот)
  ///< (меньше чем) и > (больше чем)
  ///аналог пред >= b <=

  ///Логические операции
  ///В Dart операции которые представляют условие и возвращают true or false и
  ///обычно объединяют несколько операций сравнения
  /// | (c = a|b; - c равно true если либо а либо b либо и a и b равны true иначе c = false)
  /// & (c = a&b; - c true если и а и b true)
  /// ! (c!=b; c true если b равно false и наоб)
  /// ^ (c = a^b; c true если либо a либо b(но не одноврем) true и наоб)
  /// || (с = a||b; аналог с одной |, но сначала будет вычисляться значение а, и
  /// если оно равно true вычисление b не имеет смысла и вычисл не будет)
  /// && (аналог с одной & и согласно верхнему)
  /// Последние два более удобны чем с одним знаком, так как позволяют сократить
  /// время вычисления и повысить производительность.

  /// Операции приссваивания
  /// = приравнивает одно знач другому
  /// += (с+=b; перем с присваивается результат сложения c и b)
  /// -= (c-=b; присв рез вычитания)
  /// *= и /= (присв рез умножения и рез деления)
  /// ~/= (присв рез целочисленного деления)
  /// %= (с%=b; с присваивается остаток от деления с на b)
  /// &=, |=, ^=, <<=, >>=, (с?=b; перем присв значение c&b и по аналогии другие)
  /// ??= (c ??= b; если перем с имеет знач null, то ей присваивается знач
  /// переменной b, если c не равна null,то она созраняет свое значение)
  /// Приоритет операций в таблице https://metanit.com/dart/tutorial/2.7.php

  ///Циклы
  ///Позволяют в зависим от опред условий выполнять опред действие много раз
  ///Виды циклов в Dart: for; while; do...while
  ///Цикл for - имеет след структуру =>
  /*for ([инициализация счетчика]; [условие]; [изменение счетчика])
  {
    // действия
  }*/
  ///Указывать все условия необязательно
  /*int i = 1;
  for (; ;){
    print("Квадрат числа $i равен ${i *i} \n");
  }*/ //условий нет, тк поля пустые, поэтому цикл будет работать вечно
  ///Еще можно опустить ряд блоков
  /*int i = 1;
  for (; i<9;){
    print("Квадрат числа $i равен ${i *i} \n");
    i++;
  }*/ // счетчик и приращение счетчика разбросаны по разным местам

  ///Цикл do
  ///Сначала выполняет код цикла, а потом проверяет условие в инструкции while
  ///И пока это условие истинно, цикл повторяется.
  int j = 9;
  do {
    print(j);
    j--;
  } while (j > 11); //цикл сработает 7 раз
  ///!Важно знать, что цикл do гарантирует Однократное выполнение действий, даже
  ///если условие в инструкции while не будет истинно.

  ///Цикл while
  ///В отличие от цикла do сразу проверяет истинность некоторого условия, и если
  ///условие истинно то код цикла выполняется
  int jk = 6;
  while (jk > 2) {
    print(jk);
    jk--;
  }

  ///Операторы continue и break
  ///break - позволяет выйти из цикла в любой момент
/*for (int i = 0; i < 10; i++){
    if (i == 5)
        break;
    print(i);
}*/ //когда счетчик станет равным пяти цикл завершится
  ///continue - не завершает и выходит из цикла, а просто пропускает эту итерацию
  ///и переходит к следующей
  for (int iq = 0; iq <= 9; iq++) {
    print(
        "Квадрат числа $iq равен ${iq * iq} \n"); // заметка \n для пропуска строки?!
  }

  ///Функциональное программирование
  ///Функции - некоторые действия. Можем оформить набор операторов в виде одной функции
  ///и многократно вызывать ее в программе. Формальное определение:
/* [тип] имя_функции(параметры){
 
    выполняемые_выражения
    }*/
  ///Вначале возвращаемый тип функции. Если функция не возвращает никакого значения
  ///используется тип void
  ///Затем идет имя функции - произвольное название, именование как у перем
  ///После имени в скобках - перечисление параметров. Если не имеет параметров, то
  ///указываются пустые скобки.
  ///Далее в {} скобках - тело функции, содерж выполняемые выражения
/* void main() {
}
void hello(){
 
    print("Hello!");
}*/
  ///Функция hello не возвращает никакого рез, а просто вып действия, поэтому тип void
  ///Но выполняться она не будет, по умолчанию среда выполняет только фун main,
  ///поэтому чтобы вып функ hello, ее надо вызвать в фии main:
  /* void main() {
     
    hello();
    hello();
  }
  void hello(){
 
    print("Hello!");
  } */
  ///Аргументы - знач для параметров фии.
  ///Если фия из одного выражения =>
  ///[тип] имя_функции(параметры) => выполняемое_выражение
  ///прим void hello() => print("Hello!"); из функции выше

  ///Параметры функции
  ///Перечисл в скобках после имени фии и имеет определение
  ///(тип название_параметра)
  /*void main() {
     
    sum(2, 5);  // 7
  }
  void sum(int a, int b){
    int c = a + b;
    print(c);
  } */
  /// функция sum принимает 2 параметра, с именами a и b и типами int.
  /// В main вызываем функцию sum и передаем ей два аргумента.
  /// Аргум - значения для параметров функции(перед по позиции, т.е. первый
  /// первом и тд)
  /// Колич передаваемых арг должно соответств кол-ву параметров
  /// При опред функции можем не указывать тип параметров, тогда Dart сам выводит их

  void showPerson(name, age) {
    print("Name: $name");
    print("Age: $age \n");
  }

  showPerson("Tom", 35);
  showPerson(29, "Alice");

  ///Необязательные параметры
  ///Ряд парам мы можем сделать необяз - не передав для них никаких знач.
  ///Для этого параметр заключ в [], но при этом ему нужно предоставить знач по
  ///умолчанию, которое будет использоваться если не передано никакое знач.
  ///Но если необязат параметр представляет nullable-тип, тогда можно не указ
  ///для него знач по умолчанию - в этом случае по умолч будет null

  ///Именованные параметры
  ///Dart поддерживает передачу параметров по имени
  /* 
  void main() {
     
    showPerson(name: "Tom", age: 35);
    showPerson(age: 29, name: "Alice");
    showPerson(name: "Kate");
  }
  void showPerson({String name = "undefined", int age=0}){
    print("Name: $name");
    print("Age: $age \n");
  }*/
  ///При опред функции список параметров в {}, при этом для каждого параметра, если
  ///его тип не поддерживает знач null нужно указать знач по умолч.
  ///При вызове функции указ имя параметра и через двоеточие его знач, при этом
  ///параметры можем указывать в любой последовательности.

  ///Конастанты в функциях
  ///Парам позволяют передать знач локальным переменным, которые определены в
  ///функциях. Но также можно передавать через параметры знач локальным
  ///final-константам, поскольку они определяются во время выполнения.
  ///При это const-константам такое делать нельзя, так как их знач должны быть
  ///известны уже во время компиляции.
  ///Таким образом при разных вызовах функции мы можем передать final-константам
  ///разные значения:
  void showPerson2(String userName, int userAge) {
    // const int initialAge = userAge; - так нельзя, константа должна определяться на этапе компиляции
    final String name5 = userName;
    final int age5 = userAge;
    print("Name: $name5   Age: $age5 \n");
  }

  showPerson2("Tom", 35);
  showPerson2("Alice", 22);

  ///Возвращение результата из функции
  ///Ф-ия может возвр опред знач.
  ///Для этого использ оператор return
  int sum33(int a33, int b33) {
    return a33 + b33;
  }

  /// Возвращаемый тип ставится перед именем функции.
  /// После return - какое именно значение будет возвращено(тут a+b).Причем тип
  /// значения здесь должен соответствовать типу функции.
  /// Кроме того return Завершает выпол функции, поэтому все остальные инстр в функции
  /// должны идти до оператора return.
  /// Результат функции можем присвоить переменной:
  /* void main() {
    int c = sum(2, 5);
    print(c);   // 7
  }
  int sum(int a, int b){
    return a + b;
  } */
  ///Вовзращаемый тип можем не указ. Он выведется исходя из знач после return
  ///Если функция не имеет оператора return - то в тело функции неявно добавляется
  ///инструкция return null

  ///Если функция не должна возвращать никакого знач, то она имеет тип void
  ///Причем мы может определить переменную типа void, присвоить ей результат, но
  ///ничего сделать с void-объектом не сможем:
  /* 
  void main() {
     
    void n = hello();
    // поскольку переменная n представляет тип void, 
    // ничего мы с ней не сможем сделать, даже вывести на консоль
    // print(n);
  }
 
  void hello(){
    print("Hello!");
    return null;
  }
  */

  ///Функция как объект
  ///Любая функция в Dart представляет тип Function и факт может выступать в качестве
  ///отдел объекта(ведь дарт язык ООП)
  ///Фунцкии могут выступать в качестве параметров других функций
  ///Также функция может выступ в кач вовзращаемого значения

  ///Анонимные функции
  ///Похожи на обычные, но Не имеют названия
/* void main() {
     
    Function operation = (a, b) => a + b;
    print(operation(4, 5));
}*/ //Перем operation присв ссылка на аноним ф-ию (a, b) => a + b; которая приним
  ///два параметра и возвращает сумму их знач.
  ///Где использовать? Если мы вызываем функции, которая принимает другую функцию,
  ///то для функции-параметра проще использовать анонимную.

  ///Вложенные функции
  ///В Dart функции могут быть вложенными в другие, но определение вложенной функции
  ///должно идти до ее вызова. Вложенные имеют смысл, если мы планируем использовать
  ///повтор действия только внутри опред функции
  ///Причем вложенные функции сами могут содерж другие влож ф-ии
  ///! Вложенные ф-ии создают собственный контекст - переменные и константы, к
  ///которым внешняя функция обратиться не может

  ///Замыкания
  ///Представляют объект ф-ии, который запоминает свое лексич окружение даже когда
  ///она выполняется вне своей области видим.
  ///Технически замыкание включ 3 компонента:
  ///1)внешняя ф-ия, опред некую область видимости и в которой определены перемен
  ///и параметры - лексич окружение
  ///2)перем и парам(лексич окружение), которые опред во внешней ф-ии
  ///3)вложенная ф-ия, которая использует перем и парам внешней функции

  ///Объектно-ориентированное программирование
  ///Классы и объекты
  ///Каждое значение, которым мы манипулируем в программе на Dart, является объектом
  ///Объект - экземпляр некоторого класса, а класс - шаблон или описание объекта.
  ///Класс определяется с помощью ключевого слова class
/* class Person{
 
    }  */
  ///Здесь опред класс Person. После названия - фиг скобки, между которыми тело
  ///класса - его поля и методы.
  ///Любой объект может обладать 2 основными характеристиками:
  ///1)состояние - данные, которые хранит объект
  ///2)поведение - действия, которые может совершать объект
  ///Для хранения 1) применяются поля и переменные класса
  ///Для определения 2) применяются методы.

  ///Конструкторы
  ///Кроме обычных методов классы могут опред спец методы - конструкторы.
  ///Констр вызываются при создании нового объекта данного класса. Они выполняют
  ///инициализацию объекта.
  ///Если в классе не определено ни одного констр, для автомат создается констр
  ///без параметров.
  ///Для создания объекта Person используется выражение Person(). Более старые
  ///версии Dart для вызова конструктора также использовали оператор
  ///new: Person tom = new Person();. Но в последних версиях Dart оператор new
  ///можно не использовать.
  ///После создания объекта мы можем обратиться к переменным и методам объекта
  /// через переменную. Для этого используется оператор точка (.) - то
  ///есть через точку указываем название поля или метода.

  ///null и классы
  ///Как и все встроенные типы, классы по умолчанию представляет тип, не допускающий
  ///значение null.
  ///Если же необходимо, чтобы объект класса мог хранить null добавляем к определению
  ///типа оператор ?
  ///?. (оператор проверяет знач переменной, если она не равна null, то происходит
  ///обращение к ее полям и методам, если равна, то обращение к переменной
  ///игноирруется)

  ///Именованные конструкторы
  ///По умолч - можем определить только один общий констр. Если же нам необходимо
  ///использовать в классе несколько констр - нужно прим именованные констр(name
  ///constructors)

  ///Ключевое слово this
  ///Представляет ссылку на текущий экземпляр класса. Через это ключевое слово мы
  ///можем обр к перем, методам объекта и вызывать его констр.
  ///В конструкторе параметры называются так же, как и поля класса.
  ///И чтобы разграничить поля и параметры, применяется ключевое слово this

  ///Инициализаторы - способ инициализации полей класса.
  ///Список инициализации указывает после параметров конструктора через
  ///двоеточие до открывающей фигурной скобки
  ///Стоит учитывать, что при использовании инициализаторов сначала выполняется
  ///инициализация полей в списках инициализации и только затем выполняется логика
  ///в конструкторе
/* Person(userName, userAge) : name=userName, age = userAge + 10 {
    age = 8;
}
*/ //Значение поля age будет равно восьми, тк констр перезапишет знач инициализатора

  ///Каскадная нотация
  ///.. - позволяет выполнить последовательность операций над одним объектом
/* 
void main (){
     
    Person tom = Person()
        ..name = "Tom"
        ..age = 36
        ..display();    // Name: Tom  Age: 36
} 
*/ //запись по значению аналогична записи ниже
/* 
void main (){
     
    Person tom = Person();
    tom.name = "Tom"
    tom.age = 36
    tom.display();  // Name: Tom  Age: 36
} 
*/

  ///Константы и константные конструкторы классов
  ///Кроме обычных полей-переменных классы могут определять константы.
  ///Для определения констант можно использовать ключевое слово final
  ///Значения констант классов должны быть установлены до вызова конструктора
  ///Либо установка константы возможна через параметры конструктора
/*
class Person{
 
    String name = "";
    int age = 1;
    final minAge;
     
    Person(this.minAge, n, a){
     
        this.name = n;
        this.age = a;
    }
}
*/
  ///Третим вариантом является установка значений констант с помощью инициализатора
  ///   Person(mAge, name, age): minAge= mAge + 1{  -знач могут быть динамич вычесляемыми

  ///Константные конструкторы
  ///Призваны создавать объекты, которые не должны изменяться.
  ///Предваряются ключевым словом const
  ///Класс, который определяет подобный конструктор, не должен содержать переменных -
  ///только определять константы.
  ///Такие конструкторы не имеют тела.
/*
void main (){
     
    Person tom = const Person("Tom", 23); //При вызове константного конструктора 
                                перед его вызовом ставится ключевое слово const(? возможно уже не нужно)
    print(tom.name);     // Tom
} 
 
class Person{
 
    final String name;
    final int age;
     
    // константный конструкор
    const Person(this.name, this.age);
}
*/

  ///Наследование
  ///Является одним из ключевых моментов ООП
  ///Позволяет передавать одним классам функционал других
  ///В Dart реализуется с помощью ключевого слова extends(как в Java)
/*
void main (){
    Employee bob = Employee();
    bob.name = "Bob";
    bob.display();
} 
class Person{
  
    String name = "";
      
    void display(){
        print("Name: $name");
    }
}
class Employee extends Person{
}
*/
  ///Класс Employee - подкласс, наследуется от класса Person, последний называется
  ///родительским или базовым классом.
  ///При наследовании Employee перенимает весь функционал класса Person-все его
  ///поля и методы и может их использовать.
  ///Кроме того можно определить в подклассе новые поля, которых нет в род классе.

  ///Конструкторы и ключевое слово super
  ///В отличие от полей и методов конструкторы базового класса не наследуются
  ///Если базовый класс явным образом(не по умолчанию)определяет конструктор, то
  ///его необходимо вызвать в классе наследнике при опред конструктора
  ///super - ключевое слово для обращения к функциональности базового класса из производного

  ///Переопределение методов
  ///Производные классы могут определять свои поля и методы, но также могут
  ///переопределять, т.е. изменять поведение методов базового класса
  ///Для этого нужна спец аннотация - @override

  ///Абстрактные классы и методы
  ///Классы с ключевым словом abstract
/*
abstract class Figure {
}
*/
  ///Похожи на обычные, но Не могут напрямую создать объект абстр класса используя
  ///его конструктор
  //   из пр выше Figure ellipse = Figure(); // нельзя - класс Figure - абстр.
  ///Как правило описывают сущности, которые в реальности не имеют конкретного воплощения.
  ///Напр, геометр фигуры может представлять круг, квадрат, треуг, но как таковой
  ///геом фигуры самой по себе не существует. Есть конкретные фигуры. Но все они
  ///могут иметь какой-то общий функционал, напр методы вычисления периметры, площади
/*
void main (){  
    Figure rect = Rectangle(20, 30);
    rect.calculateArea();
} 
abstract class Figure {
    void calculateArea(){
        print("Not Implemented");
    }
}
class Rectangle extends Figure{      
    int width;
    int height;
    Rectangle(this.width, this.height);     
    void calculateArea(){
        int area = width * height;
        print("area = $area");
    }
}
*/
  ///Здесь абстрактный класс геометрической фигуры определяет метод
  ///calculateArea(), который выводит на консоль площадь фигуры. Класс
  ///прямоугольника определяет свою реализацию для этого метода.

  ///Абстрактные методы
  ///В п выше метод calculateArea в базовом классе Figure не выполняет полезной работы,
  ///тк у абстр фигуры не может быть площади
  ///В этом случае метод лучше определить как абстрактный
  ///Абстрактный метод определяется также, как и обычный, только вместо тела
  ///метода после списка параметров идет точка с запятой: void calculateArea();
  ///! Важно, что абстр методы могут быть определены только в абстр классах
  ///Также если базовый класс определяет абстрактный метод, то класс наследник
  ///обязательно должен его реализовать, то есть определить тело метода

  ///Реализация интерфейсов
  ///Наследование в языке Dart имеет важное ограничение: мы не можем наследовать
  ///класс сразу от нескольких классов
  ///Для решения этой проблемы в Dart применяется реализация интерфейсов
  ///При этом важно понимать, что интерфейс - это не отдельная сущность, как в
  ///некоторых языках программирования(C# или Java)
  ///В Dart класс одновременно выступает в роли интерфейса и другой класс
  ///может реализовать данный интерфейс.
  ///Интерфейс - синтаксич контракт, которому должны следовать реализ этот интерфейс
  ///классы. То есть если класс - интерфейс определяет какие-нибудь поля и методы,
  ///то класс, реализующий данный интер должен также определить эти поля и методы
  ///оператор implements - применяется для реализации интерфейсов
  ///По сути интерфейс - контракт, что класс должен содержать опред. функционал

  ///Наследование классов vs реализация интерфейсов
  ///При наслед производный класс Не обязан определять те же поля и методы, которые
  ///есть в базовом классе(за исключ абстрактных методов). Если в базовом классе опред
  ///конструктор, то производный кл обязан опред свой конструктор, при котором вызыв
  ///констр базового. В производном классе мы можем обращ к реализации базового класса
  ///с помощью ключ слова super. Не поддерж множественное наслед
  ///При реализации интерфейся производ класс Должен опред Все поля и методы из
  ///класса интерфейся. Если в базовом есть констр, то производный Не обязан опред
  ///свой констр. В производном классе мы Не можем обращаться к методам реализ
  ///интерфейся с помощью ключ слова super. Поддерж множеств реализация интерфейсов.
  ///! хорошее объяснение в комментах на метанит этой темы.

  ///Миксины
  ///Еще одно решение проблемы множественного наследования в Dart
  ///По сути, миксин - обычный класс, но который Не должен содержать конструктор, иначе
  ///он не может быть использован в кач-ве миксина
  ///оператор with - оператор для использования миксинов
  /// class Employee extends Person with Worker{
  ///Класс Worker выступает в роли миксина. Теперь класс Employee может
  ///использовать поля и методы от класса Worker. При этом Employee может наследовать
  ///от других классов, как здесь от класса Person
  ///Кроме того, тк Worker определен как обычный класс, мы можем использовать его
  ///независимо
  ///В то же время мы можем указать, что данный тип будет испол только как
  ///миксин(если не планируем испол его в качестве отд класса). В этом
  ///случае для определения типа применяется ключевое слово mixin

  ///Статические члены классов
  ///Кроме обычных методов и полей класс может иметь статич поля, методы,
  ///константы. Значения таких полей, методов и констант относятся в целом ко
  ///всему классу, а не к отдельным объектам.
  ///static - ключ слово для определения статич переменных, констант и методов
  ///перед их объявлением

  ///Статич поля
  ///Хранят состояние всего класса
  ///Определяется как обычное, только впереди ставят ключ слово static
  ///Если мы хотим обратиться к этому полю вне класса, например, изменить его
  ///значение, то для обращения применяется имя класса потом .(dot) потом имя поля.

  ///Статич константы
  ///Применяется если значение менять не планируется
  ///Для определения статической константы можно использовать либо выражение
  ///static const, либо static final

  ///Статические методы
  ///Как правило выполняют такие вычисления, которые не затрагивают состояние
  ///или поведение объекта
  ///предваряются ключевым словом static
  ///Статич методы могут использоваться для управления статич полями, то есть
  ///состоянием которое относится ко всему классу. В то же время в статич методах
  ///мы не можем использоваться нестатич методы и поля класса

  ///В чем преимущества статич полей и методов перед нестатич?
  ///Первые потребляют меньше памяти.
  ///Нестатич перменная после инициализации(при первом присвоении знач) сразу
  ///начинает потреблять память независимо от того, исопльзуется она или нет. А
  ///статич поля и методы не инициализир до того момента, пока они не начнут использоваться
  ///в программе. То есть потреблять память начинают тогда, когда непосредственно
  ///начинают использоваться
  ///Статич полям и методы инициал один раз, тогда как динамич создаются для каждого
  ///экземпляра класса и поэтому потреблеют в х раз больше, во сколько х раз больше
  ///экземпляров создано. Если экз один, то разницы нет вроде (?)

  ///Generics(обобщения)
  ///Позволяют добавить программе гибкости и уйти от жесткой привязки к опред типам
  ///Иногда нужно опред функционал, чтобы он мог использовать данные любого типа
  ///<T> - выражение для указания, что класс типизирован определенным типом Т.
  ///Т еще называют универс параметром
  ///Причем название параметра может быть произвольным, но обычно используются
  ///заглавные буквы, часто буква Т. После, мы можем использовать Т как обычный тип,
  ///например определять перем этого тип: Т id;
  ///При выполн прогр вместо Т будет подставляться конкретный тип. Причем тип будет
  ///вычисляться динамич на основе переданных знач.
  ///С помощью поля runtimeType можем получить конкретный тип данных переменной.
  ///Мы также могли бы явным образом обозначить, какие типы будут использоваться в
  ///объектах. Тип, которым типиз класс, указывается в угловых скобках после
  ///названия класса Person<String>
  ///Подобным образом можем определять generic-методы и функции
  ///Для создания обобщ метода после имени указыв в угловых скобках название
  ///универ параметра   void log<T>(T a)

  ///Ограничение обобщений
  ///Иногда необходимо использовать обобщ., однако принимать любой тип в функцию
  ///или класс нежелательно.
  ///<T extends Account> //Account из примера - указываем что используемый тип Т
  ///обязательно должен быть классом Account  или его наследником. Благодаря подобному
  ///огранич мы можем использовать внутри класса все объекты типа Т именна как объекты
  ///Account и соотв обращаться к их полям и методам

  ///Фабричный конструктор
  ///По умолч конструкторы класса создают и возвращают новый объект этого класса
  ///Но, возможно, не всегда потреб создавать новый объект класса. Возможно мы захотим
  ///использовать и возвращать из конструктора уже имеющийся объект. Для этой цели
  ///в Dart примен Фабричные конструкторы
  ///factory - ключевое слово для фабр констр
  ///! В фабричных конструкторах нельзя обращаться к текущему объекту через
  ///ключевое слово this

  ///Переопределение операторов
  ///Dart позволяет изменить поведение ряда встроенных операторов, что позволяет
  ///нам воспользоваться доп возможностями по работе с объектами.
  ///Пример - Dart не знает как складывать объекты классов определенных разработчиком,
  ///а не только объектов примитивных типов.
  ///Для этого нам и нужно переопределить соотв операторы.
  ///Переопределение операторов закл в определении в классе спец метода:
  ///возвращаемый_тип operator оператор(параметр) {  }
  ///Вовзр тип представляет тот тип, объекты которого мы хотим получить.
  ///В завивисмости от задачи - возвращаемые типы могут быть любыми.
  ///Далее вместо навания метода идет ключевое слово operator и, собственно,
  ///сам оператор. И далее в скобках параметр.
  ///! Много вопросов здесь, не оч понял

  ///Перечисления
  ///Особый тип классов, который представляет фиксир набор константных знач
  ///enum - ключевое слова для опред перечислений
  ///Для обращения к перечислениям указывается название перечисл и через точку константа
  ///print(Operation.multiply);
  ///Еслы выведем на консоль знач константы, то увидим ее название - Operation.multiply
  ///Однако с каждой константов также сопоставляется числ индекс, который можем получить
  ///через поле index(Operation.multiply.index).
  ///Обычно переменна перечисл выступает в качестве хранилища состояния, в зависим
  ///от которого производятся некоторые действия

  ///Коллекции
  ///List (список)
  ///List<T> или список, представляет набор значений. В других языках программ
  ///ему соответствуют Массивы.
  ///var list = [1, 2, 3];
  ///var list = [1, 2, 3]; //можем явно указать тип
  ///При опред массива ему присв список элементов в []
  ///Для обращения к элементам массива применяются индексы. Индекс - номер элемента
  ///в массиве, нумерация при этом начин с 0.
  ///чтобы обратиться к 4 элементу в списке: list[3]
  ///Если обратимся по несуществ индексу - столкнемся с ошибкой
  ///Для перебора списка можем использовать встроенные циклы for/while
  ///Но также спец форму для коллекций
  /*
  void main (){
    var list = [2, 4, 6];
    for (var n in list){
        print(n);
    }
}       //при переборе списка list каждый элем помещается в перем n
  */

  ///Фиксированные и нефиксированные списки
  ///Фикс - жестко опред размер.
  ///Нефикс - могут увеличиваться в размерах
  ///Пример нефикс
  /* var list1 = [];
  var list2 = [2, 4, 6];
  */
  ///Отлич особ нефикс списков - мы можем динамич изменять их размер
  ///add - метод, с помощью которого можно добавить новые эл-ты в нефикс список
  ///Для создания фикс списка - один из именованных конструкторов класса List
  ///List.filled(колво_элементов, знач_по_умолч), знач по умолч = значение для всех
  ///элементов при создании списка
  ///Хоть список и фикс - можем менять знач отдельных элементов(нельзя только добавлять их)
  ///List.generate(количество_элементов, функция_наполнения, можно_ли_добавлять)
  ///Функция наполнения - в кач параметра передается индекс списка
  ///Можно_ли_добавлять-булевое знач, если true, то список нефикс(расшир), false-наоб.

  ///Основные св-ва списков
  ///first: возвращает первый элемент
  ///last: возвращает последний элемент
  ///length: возвращает длину списка
  ///reversed: возвращает список, в котором все элементы в противоп порядке
  ///isEmpty: возвращает true, если список пуст

  ///Основные методы списков
  ///add(E value):добавляет элемент в конец списка
  ///addAll(Iterable<E> iterable): добавляет в конец списка другой список
  ///сlear(): удаляет все элементы из списка
  ///indexOf(E element): возвращает первый индекс элемента
  ///insert(int index, E element): вставляет элемент на определенную позицию
  ///remove(Object value): удаляет объект из списка (удаляется только первое
  ///вхождение элемена в список)
  ///removeAt(int index): удаляет элементы по индексу
  ///removeLast(): удаляет последний элемент списка
  ///forEach(void f(E element)): производит над элементами списка некоторое
  ///действие, которое задается функцией-параметром, аналоги цикла for..in
  ///sort(): сортирует список
  ///sublist(int start, [ int end ]): возвращает часть списка от индекса start до индекса end
  ///contains(Object element): возвращает true, если элемент содержится в списке
  ///join([String separator = "" ]): объединяет все элементы списка в строку.
  ///Можно указать необязательный параметр separator, который будет раздлять элементы в строке
  ///skip(int count): возвращает коллекцию, в которой отсутствуют первые count элементов
  ///take(int count): возвращает коллекцию, которая содержит первые count элементов
  ///where(bool test(E element)): возвращает коллекцию, элементы которой
  ///соответствуют некоторому условию, которое передается в виде функции

  ///Set
  ///Класс из неупорядоченного набора уникальных объектов.
  ///Для создания применяются фиг скобки {}
  ///Для перебора набора можно использовать цикл for..in
  ///Отличит особенность - содержат только уник значения, мы не можем добавить
  ///одни и те же значения в набор несколько раз
  ///Свойства и методы похожи на списки(массивы), перечислять не буду, ниже ссылка
  ///https://metanit.com/dart/tutorial/5.2.php

  ///Map
  ///Класс Map-коллекция элементов, где каждый элемент имеет ключ и значение.
  ///Ключ и знач элемента могут представлять разные типы
  ///Для создания объекта Map:
  ///1)фигурные скобки, внутри которых помещаются пары ключ-знач
  /*    var map = {
        1: "Tom",
        2: "Bob",
        3: "Sam"
  };        */
  ///2)конструктор класса Map
  /*    Map<int, String> map2 = {
        1: "Tom",
        2: "Bob",
        3: "Sam"
    };  */
  ///Используя ключи, мы можем получить или изменить значения элементов
/*    map[2] = "Alice";   // установим значение элемента с ключом 2
    print(map[2]);      // получим значение элемента с ключом 2     */

  ///С помощью конструктора Map можно создать пустой объект Map и потом добавлять
  /// в него объекты:       var map = Map();    // пустой Map
  ///Добавление нового элемента довольно просто: в квадратных скобках указываем
  /// ключ и присваиваем ему какое-либо значение map[6] = "Sam";
  
  ///Свойства и методы Map
  ///Основные свойства:
  ///entries: возвращает объект Iterable<MapEntry<K, V>>, который предст все эл-ты Map
  ///keys: возвращает объект Iterable<K>, который представляет все ключи Map
  ///values: возвращает объект Iterable<V>, который представляет все значения Map
  ///length: возвращает количество элементов в Map
  ///isEmpty: возвращает true, если Map пуст
  
  ///Каждый элемент в Map фактически представляет объект MapEntry<K, V>, 
  ///где K - тип ключей, а V - тип значений.
  
  ///Основные методы Map:
  ///addAll(Map<K, V> other): добавляет в Map другой объект Map
  ///addEntries(Iterable<MapEntry<K, V>> newEntries): добавляет в Map коллекцию Iterable<MapEntry<K, V>>
  ///clear(): удаляет все элементы из Map
  ///ontainsKey(Object key): возвращает true, если Map содержит ключ key
  ///containsValue(Object value): возвращает true, если Map содержит значение value
  ///remove(Object key): удаляет из Map элемент с ключом key
  
///Обработка исключений
///Блок try..catch
///В процессе работы прогр возник разл ошибки и даже заставляют её прервать
///выполнение
///Такие ошибки - называются Исключениями (exceptions)
///Dart, как и многие ЯП, поддерживает обработку исключений, что позволяет избежать
///аварийного прерывания работы программы.
///Что предлагает Dart для обработки подобных ситуаций?
///Прежде всего конструкция try...on...catch...finally
///вначале выполняются все инструкции в блоке try
///если в блоке нет исключений - блок finally
///если есть - переходит к блоку on или catch, который может обработать возникшее
///исключение. Если нужный блок on или блок catch найден, то он выполняется и
///после его завершения - блок finally
///Разницу м/у on & catch в том, что оn обрабатывает искл опред типа, а catch-все.
///Если нужный блок on или блок catch не найдет, то при возникн исключ - опять 
///выполняется блок finally, а программа затем аварийно завершает своё выполнение

///При определении конструкции мы можем опускать ряд блоков, если они не нужны. 
///Только блок try является обязательным. Однако вместе с ним должен также 
///использоваться, как минимум, либо блок on и(или) catch, либо блок finally.

///Параметры блока catch
///В блок catch передается ряд параметров, которые несут инфо об исключении и 
///мы можем получить и использовать эту инфу:
///e - представляет объект исключ
///s - стек исключ, чтобы понять где произошло искл

///Классы исключений
///Ключ класс для обработки исключ в Dart - класс Exception, который является
///базовым классом всех остальных исключений 
///По умолч - стандартн библиотека предоставл. ряд встроенных типов исключ
///Напр исключ типа IntegerDivisionByZeroException, встроенного класса, который
///наслед от Exception
///В констр try..catch мы можем обрабатывать исключ опред типа, для этого оператор -
///on - оператор для обраб исключ. После него указ тип исключ для обработки

///Встроенные типы исключений
///Список на https://metanit.com/dart/tutorial/6.2.php

///Оператор throw и создание своих типов исключений
///Оператор throw
///Позволяет сгенерир искл в необход месте

///Создание своих исключений
///Для отдельных ситуаций может понадобится создать собственные типы исключений

///Асинхронность
///Введение в асинхронность и Future
///Зачем нужна асинхр? Чтобы помимо основного потока, различные действия программы, 
///сетевые запросы и другие Тяжеловесные задачи могли выполняться одновременно друг
///с другом - асинхронно
///Dart - однопоточный язык и может выполнять только одну задачу в единицу времени
///Но благодаря реализации циклу событий(event loop) и двух очередей событий(event
///queue и microTask queue)он позволяет асинхронно выполнять различные задачи.
///Когда запускается любое приложение на Dart, начинает выполняться единственный 
///поток приложения. Он инициализ две очереди - MicroTask и Event, которые содержат
///задачи к выполнению
///Далее поток запускает функцию main(), а после ее завершения - событийный цикл или
///Event Loop. В этом цикле последов извлекаются и выполняются все задачи из очередей
///Microtask и Event.
///Microtask-хранит небольшие внутренние задачи, которые должны выполн. асинхронно
///Event-очередь, в которую помещается основная часть задач. Это внешние события,
///например события граф интерфейса(нажатия на кнопки и тп), таймеры, чтение-запись
///файлов, работа с потоками и т.д. А также объекты Future

///Класс Future
///Ключевой класс
///Представляет собой рез-т отложенной операции, которая завершит свое выполнение
///в будущем. Результатом может быть некоторое знач или ошибка.
///Объект Future может наход в 2 состояниях:незавершенном(Uncompleted) и 
///завершенном(Completed). В незаверш состоянии операция, которую предствл объект
///Future определен, возможно, уже начала выполняться, но рез-т еще не получен.
///В завершенном состоянии операция уже завершила свое выполн, ее руз-т - некое
///знач или ошибка - получен

///Работа с классом Future
///Конструкторы Future
///по ссылке большой список - https://metanit.com/dart/tutorial/7.2.php

///Получение значения
///В реальности тип Future - generic-тип или обобщенный тип, который типизируется
///определенным типом - Future<T>. Т в угловых скобках как раз и представляет тип
///знач, который несет Future.

///Получение значения и использование Future
///Ранее мы определили ряд объектов Future. При их определении все они находятся 
///в Незаверш состоянии, им только предстоит выполниться. Как поймать момент, когда
///они уже выполнены и перешли в Завершенное состояние? Для этого у Future есть
///метод then-он принимает функцию обратного вызова, которая будет срабатывать
///при заверш Future. В кач единственного параметра ф-ия принимает получ из
///Future знач.
///При необходимости мы можем создавать цепочки методов then, которые будут 
///выполняться друг за другом.
///!return(возврат чего-то) - это значения(числа, строки и тп) которые впоследствии
///могут быть использовандругими методами и тп. Для этого он и сделан?
///Параметр функции из каждого последующего метода then - это результат функции
///из предыдущего метода then.

///Обработка ошибок
///В случае возникноввения ошибки при работе операции, которую представляет Future - 
///при переходе в заверш состояние Future вместо конкрт знач будет хранить инфу 
///об ошибке. Для получ инфо об ошибке можно использовать метод catchError(),
///который работает аналогично методу then - принимает функцию обратного вызова,
///в которую передается информация об ошибке

///Метод whenComplete
///whenComplete - выполняет некоторую функцию при завершении Future
///Эта ф-ия выполняется вне зависимости возникла во Future ошибка или нет - после
///всех функций из then и catchError.

///Асинхронные функции и операторы async и await
///В последних подверсиях в Dart  были добавлены операторы async и await
///Они облегчают написание асинхронного кода, тк применение async-await позволяет
///уйти от прямого изпользования Future Api, в частности его методов then и
///catchError

///Асинхронная функция-ф-ия которая содержит как минимум одну асинхронную операцию
///(хотя также вместе с этим может содержать и выполнять и синхронные операции).
///Асинхронная функция выглядит как синхронная за тем исключением что использует
///операторы async и await
///Асинхронная функция выполняет синхронно весь код, который идет до первого вызова
///выражения await.
///await представляет асинхронную операцию - такая операция, которая не блокирует
///выполнение других операций и позволяет им выполняться до своего завершения.
///Выражение await обычно возвращает объект Future. Если объект другого типа - он
///автоматически обертывается во Future. И этот объект, который хранится во Future,
///мы можем получить простой операцией присваивания.
///Стоит отметить, что если функция использует await, то она обязательно должна
///быть определена с ключевым словом async
///Также стоит отметить, что асинхронная функция может содержать несколько 
///выражений await. В этом случае они выполняется последовательно

///Обработка ошибок
///Если в процессе выполнения долговременной операции произошла ошибка, то 
///объект Future вместо конкретных данных будет содержать информацию об ошибке
///Для обработки подобной ситуации достаточно поместить выражение await в блок try..catch
///Для имитации ошибки вызываем оператор throw, после которого указываем текст ошибки

}
